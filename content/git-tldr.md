---
title: Git TLDR
---

基本的 Git 概念解读，面向全体 IT 人员。

## VCS / SCM

- 如果我们不希望出现`我的文档.doc`、`我的文档-20231024.doc`、`我的文档v1.doc`、`我的文档最终版.doc`、`我的文档最终版2.doc` 这样的状况，自然就能理解版本控制系统（Version Control System / VCS）的由来。
- VCS 记录了每一次变更，包括谁、在什么时候、修改了哪部分内容，当然也就能轻松恢复到某个时间点的状态。
- VCS 经常还叫做源代码管理（Source Code Management / SCM），因此产生了很大误导，以为只有开发人员需要 VCS。
- **运维人员同样需要 VCS** 来管理配置文件、脚本、SQL 等等的版本历史，即使是在 GitOps（GitOps TLDR，TODO）兴起之前。
- 创作技术文档的 [Markdown](markdown-tldr.md) 同样需要 VCS / SCM，或者换个角度，也可以将配置文件、Markdown 等看成另一种形式的源码。
- 在需求上 **Office 文档、Photoshop 文件等当然也需要版本管理**，在技术上 VCS 也支持任意类型的文件，但是以当前主流的 VCS 产品 Git 为例，更适合的还是文本文件，主要是因为文本一者体积特别是压缩后的存储体积非常小，二者文本的不同版本比对非常直观、而二进制文件除非有针对性的插件否则完全看不出修改了什么。
- 虽然二进制文件有以上限制，但在规模不大时仍然强烈建议使用 Git 等工具管理，因为记录变更历史、恢复版本等核心功能并无二致；而规模大时更应该考虑版本管理，但需要寻求优化方案。

## Git Vs SVN

- VCS 的发展包括本地、集中式（CVCS，以 SVN 为代表）和分布式（DVCS，以 Git 为代表）三个阶段，但并不是说后者就完全取代了前者。
- 考虑到团队协作，在企业环境不可能使用本地 VCS，而无论集中式还是分布式，要处理的问题会复杂许多，典型如不同用户修改同一文件所引起的版本冲突。
- 因为 SVN 完整的版本库只保存在服务器端，用户离不开 SVN 服务器，这是集中式受到诟病的一大原因，但在传统企业 IT 似乎也不是很关键；而集中式的这种设计也不是只有坏处没有好处，如更细粒度的权限控制、文件锁[等等](https://subversion.apache.org/features.html)。
- Git 的每个用户在本地都有完整版本库，在断网时同样可以本地提交变更，这也是分布式的由来。
- 但注意即使是分布式的 Git，通常还是会有一个集中的 Server 用于协助用户同步变更，虽然技术上完全可以做到两个用户直接同步。
- 个人认为 [Rewriting History](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History) 是 Git 优于 SVN 的关键之处，这个在下一节展开。
- Git 的概念比 SVN 要多，用户操作上更复杂、学习成本较高。
- 但总的来讲我们选择 Git 而非 SVN 最主要的原因仍然是**发展和生态**，这也是所有技术选型的重点；GitHub 从名称就可以看出倾向，而最新（2023-11）的 [Subversion Releases](https://subversion.apache.org/docs/release-notes/) 还停留在 2020 上半年。
- 当然在 VCS 领域远不止 Git、SVN 两个选项，如 Google、Facebook 选择的 Monorepo 方案，但感觉离我们太远。

## Rewriting History

- 源代码管理的一个原则是必须真实记录每一次提交，但在我们实际代码库中，存在着连续十个描述完全相同的提交，就是不停在同一行代码上尝试，其他即使没这么极端但也是相当常见的行为。
- 即使不考虑以上的离谱行为，如果用户提交一个变更时某标题漏了一个字母，这种情况是应该再补一个提交还是修改之前的提交？
- 在工程实践中，保持变更历史的干净整洁是要强于绝对保证历史真实的，真正关注代码的人不可能对以上那种提交记录无感。
- 当然这并不是说就可以随意变更历史，这个我们在 Git Run TLDR（TODO）中讨论。
- 总之会不会、有没有意识 `git commit --amend`，个人认为这是有没有真正掌握 Git 的一个明确指标。

## GitHub / GitLab

- 虽然 Git 用户可以两两直接同步变更，但在实际的团队协作场景，还是需要一个服务器居中调度，包括更重要的权限控制等，GitHub / GitLab 平台就是这种角色。
- 虽然 Git 是分布式，但 GitHub / GitLab 仍是集中式的，而整个 DevOps 环节对后者的依赖也很大、出现故障后一样会造成严重影响，所以说只有人员也是分布式的开源项目才能获得 Git 的最大好处。
- GitHub / GitLab 除了提供 SaaS 服务以外也都提供本地部署，但是只有 GitLab 有开源版本，再考虑到 GitHub 美国出口管制等因素，企业内大量使用的还是 GitLab。
- 在不考虑团队协作的个人思考学习等场景，仍建议使用 Git 管理自己的文档或其他文件、并保存到企业内的 GitLab；即使不考虑 Git 服务器、只希望本地保存，一样建议使用 Git 管理本地版本，差别在于有没有备份。
- 随着 GitHub / GitLab 多年的发展，两者早就不止是 SCM 了。GitLab 对自己的定位是 DevSecOps Platform，而 GitHub Issues 可以说是开源项目最丰富的知识库、反馈最及时的支持社区，所以真不能将 GitHub 当源码库封了。
- 很多云服务对于用户创作的内容也都提供了版本管理功能，比如飞书文档，但个人并不喜欢，因为是一个黑盒状态，所以现在的做法还是使用 Git 管理并手工同步到飞书（大致找了下，飞书貌似没有直接从 Git 服务器同步文档的功能）。
  - 另外可能有用户注意到在飞书文档多个用户编辑同一 Word / Excel 文件很方便，但这和代码开发是两个场景，同一个 Word 只需要考虑不同用户别编辑同一行内容就行、编辑后简单合并各方内容即可，但同一个源码文件要考虑的不是简单的文本合并、而是程序逻辑能不能合并，所以开发场景从设计上就要尽量避免不同用户同期修改同一个源文件。

## Conventional Commits

每次提交变更（Commit）用户都应该提供概要描述，业界在这方面同样也有最佳实践或规范但并未形成统一标准，因此以下只是简单介绍一下，阅读开源代码时少一点门槛。

- 对每次变更的描述如果不能简明扼要、重点突出，或者说只想用泛泛的 `Update` 语句应付过去，那么大概率也并没有真的想清楚变更的问题场景、或者真的恰到好处的解决了问题。
- [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) 等提供了一些形式上的规范，虽然不能提升由人主观决定的内容质量，但乐观想这个形式化框架还是会产生一些潜移默化的影响。
- 开源项目常见的一种 Commit 标题格式是 `<type>: <description>`，其中的 Type：
  - `fix`、`docs`、`refactor`、`test` 基本能望文生义。
  - `feat` 为 `feature` 缩写，`perf` 为 `performance` 缩写。
  - `ci` 是持续集成相关，比如变更了持续集成配置。
  - `chore` 代表不用专门分类的杂事。
  - `bump` 升级版本。
- 除了语义上更清晰以外，这样做的好处还包括自动生成 CHANGELOG。
- 但实际上虽然在大多数开源项目的 Commit 都能看到以上字眼，但是用词或格式方面并未严格遵守，即使是同一个项目；这也是我们在做规划时需要注意的，即使目标再理想，做不到也不要强求。

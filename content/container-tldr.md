---
title: Container TLDR
---

基本的容器概念解读，面向全体 IT 人员，具体的技术实操参见 [Container Run TLDR](container-run-tldr.md)。

## General

- 可以将容器（Container）看作更轻更快的 VM，特别是从用户视角，进入容器后所见内容和操作方式与 VM 并无二致。
- 实际上容器并不是 VM，它没有独立安装而是共享宿主机的 OS，所以 Linux 容器无法运行在 Windows 宿主机。
- **容器的轻和快远不是简单的技术结果，而是设计重点追求的目标**，比如分层重用，比如尽量舍弃非必须的依赖或工具，以及一个容器只提供一个服务的最佳实践指导等等。
- 将应用打包为容器后，无论容器内是 Java 还是 Go 等等等等，唯一的外部依赖就是容器运行环境，应用部署全部统一成了容器部署（想想集装箱），至此**容器成为了最先进、最标准化的应用交付方式**。
- 一个容器一个服务的设计或者说约束，减小体积只是一方面，同时因为其专一也极大消除了依赖冲突；再考虑到和 VM 一样封装了所有系统库第三方库、甚至可以说连 OS 都打包自带、将对外的依赖降到最低，容器基本算得上完美解决了软件领域的 [Dependency hell](https://zh.wikipedia.org/wiki/依赖地狱) 这一大麻烦。
- 容器成熟度：应不应该上容器早十年就成了一个 Boring（无需讨论）话题。
- 应用容器化后离真正的生产可用仍有一段距离，还需要容器编排，这个我们在 [Kubernetes TLDR](k8s-tldr.md) 中介绍。
- 引入容器极大简化了部署运维，但并不代表其中的问题就凭空消失了，这个我们在 [DevOps](devops-talk.md) 中讨论。

## Terminology

- **容器和容器镜像**：容器这个词在泛泛讨论时通常代表容器技术，但在具体运维工作中则多指应用运行的容器实例，针对后一个含义，容器和容器镜像可以类比为运行中的程序进程和保存在硬盘的执行文件。
- **镜像或制品**：注意中文的镜像对应到英语中有两个含义，一个是容器镜像（Image），另外也指外部第三方软件制品在企业内的拷贝或缓存（Mirror），请注意通过上下文区分，或者就叫容器制品。
- **Docker**：容器技术的先发者，但现在已不占主导地位了，在我们的交流语境中提及 Docker 通常是指容器技术而非特定的 Docker 产品。
- **Docker Hub**：开源容器制品的最大集散地，还包括 [Amazon](https://gallery.ecr.aws/)、[GitHub](https://ghcr.io/)，但注意即使是这些大网站也**尽量只使用其中的官方或认证镜像**。
- **官方镜像**：在容器技术刚兴起时，各应用厂商自己没意愿投入、Docker 公司主动制作了大量主流应用的容器镜像，但现在厂商自己同步推出最新镜像已成为普遍现象；因此如果不纠结"官方"的字面意思，这两种来源的容器镜像都可以认为是正规、官方的。
- **OCI**：容器标准化组织，制定容器镜像格式及运行时规范，对于普通用户可以将 Docker 镜像和 OCI 镜像当作一回事，当然实际上还是有区别的。
- **Dockerfile 或 Containerfile**：用于将应用构建为容器镜像的配置文件，叫 `Dockerfile` 是历史原因，当然也可以构建 OCI 镜像，而现在也有很多就叫 Containerfile。
- **Registry**：容器镜像仓库通常叫 Registry 而非 Repository，本地部署产品包括通用且支持容器的 JFrog 以及专门针对容器的 Harbor 等。
- **Podman**：简单粗暴的说可以将其理解为更好的 Docker，命令与 Docker 基本一致，如非必须建议**尽量使用 Podman 取代 Docker**。

## From VM To Container

用户从 VM 转向到容器时需要注意的问题：

- 从 VM 到容器的跨度要**远大于**从物理机到 VM 的跨度，但不仅是这两个技术的差别所引起，还包括不同阶段其他配套技术的迭代，如不可变基础设施、Kubernetes 等等。
- 从物理机到 VM，其实也应该有调整的，典型的如一台机器部署多个应用实例，到很容易定制配置的 VM 时就完全没必要了，但一者用户没意识调整部署方案，二者申请 VM 仍很麻烦，导致了大多时候就是把 VM 当物理机用。
- 而从 VM 到容器，除了早期阶段基本都会同时引入容器编排方案 Kubernetes，导致了用户**一开始就要学习大量的新概念，加大了迁移难度**；但即使在 VM 时期也是有大量新概念的配套技术，如果当时跟进了那现在会轻松很多，所以**本质上讲上 Kubernetes 的难度有一大半是在偿技术债、而不是凭空多出的**。
- VM 和容器一个很大区别就是不可变基础设施，简单说重启一个 VM 不会丢失运维人员之前的手工修改，但容器会还原为初始状态；注意这是一个**设计上的结果**而非技术差别，VM 一样可以实现不可变基础设施、容器也可以持久保存。
- 虽然技术上支持挂载存储保存日志，但通常是**将应用日志转为标准输出**、然后由容器运行环境做持久化保存；而这里还有一个理念上的差别，也就是云原生认为日志是一种事件流、应用本身不需要操心如何存储和管理日志文件。
- 虽然从运行上可以将容器看作一种 VM，但从应用部署上要习惯一个容器只包含一个功能模块（[one service per container](https://docs.docker.com/config/containers/multi-service_container/)）；如我们的 OpenShift 4 集群会启动 200 多个非业务应用容器，如果将容器当作 VM 那显然太笨重了，但将每个容器理解为 Linux 的一个服务，实际上就是 10 台物理机平均 20 个服务进程在支撑一个 PaaS 平台。
- 部分传统的 Debug 手段会变得麻烦，如进入 VM、修改一个配置、重启服务就可以验证，但容器需要从外部调整；VM 可以针对多实例之一操作，但容器往往是整体修改；虽然都是 Linux，但容器出于最小镜像的设计原则导致了很可能没有 `telnet`、`ss` 等常用 Debug 工具；但这**不代表**容器 Debug 就会变得难上很多，而是说**用户要学习适应新的 Debug 方式**。
- 过时的技术栈可能识别不出容器的 CPU / 内存配置，而会误将宿主机当成可用配置从而导致 OOM 等，请首先**升级技术栈**比如 Java 强烈建议 11 LTS 或更上版本。
- 容器或者说在最常见的 Kubernetes 容器运行环境中，容器 IP 是随机分配且不对外暴露，而 VM 往往是公共的静态 IP，因此**传统的 IP 安全控制不再适用**。
- 从安全上来讲容器隔离毕竟没有 VM 彻底，虽然早有以非 root 用户运行业务应用的最佳实践，但到我们的容器运行平台 OpenShift 控制得更严，必须能以随机的十位数 UID 运行且无权限问题。

## Java in Container

- 由于我们主要使用 Java 开发业务应用，因此容器会对 Java 技术产生什么影响也是我们关注的重点。
- Java 的"Write Once Run Anywhere"目标是通过 JVM 实现的，而到容器时代，作为"Container VM"，也基本是可以 Run Anywhere 的，显然两者产生了重叠。
  - 当然 Linux 容器不能运行在 Windows 宿主机，但在真实场景，这个限制并无影响，因为我们生产环境的 Java 应用也都部署在 Linux 上。
- 由于 JVM 和容器的重叠，当 Java 应用运行在容器时，实际上就是多出了不必要的一层；对比如 Nginx 或 Go 应用，Java 的启动速度慢一两个量级，内存占用同样很尴尬，**从这个角度，可以说 Java 是不适合容器化的**。
- 当然 Java 界也在尝试解决这个问题，以 GraalVM 的 [Native Image](https://www.graalvm.org/latest/reference-manual/native-image/) 技术为例，就在考虑如何移除 JVM 这一层：["It does not run on the Java VM, but includes necessary components"](https://www.graalvm.org/22.1/reference-manual/native-image/index.html)。
  - 但很显然这是不够 Native 的补丁方式。
  - 不 Native 的意思是要么达到的效果不如 Native，要么需付出极大努力解决 Native 方式不存在的困难。
  - 当然如果只是 GrallVM Native Image 内部实现复杂，不影响最终用户（开发团队）就好，但从我们 2022 年底的[*尝试*](why-here.md)，构建的耗时、对内存的要求等等都很不乐观。
  - 虽然针对 Java 的 Native Image 等方式也会不断进步，但从原理上来讲，这种设计初的限制、内部的复杂性无论怎么封装总是会影响到最终用户，所以即使将来大规模转到这个方向，也应该是考虑到 Java 生态圈等等的工程权衡结果。
- 由于 Java Native Image 不是目前（2025）的主流方式，而实际又不可能放弃 Java，我们主要关注在容器中运行 JVM 会遇到的问题。
  - 早期的一个主要问题是 JVM 不能正确识别容器的 CPU、内存等信息，而是基于容器所在宿主机的配置，这样常会引起 OOM，另外我们实际也遇到过 Java 应用根据宿主机 CPU 核数来预分配资源引起的故障，这个问题在 [JDK 8u191](https://www.oracle.com/java/technologies/javase/8u191-relnotes.html) 彻底解决。
  - 但是注意以上方案是"introduced in JDK 10"然后下放到 8 的，所以彻底解决该问题的版本是 Java 8 的小版本 191 及更高、或者 Java 10 及更高版本，而其他版本虽然也有更麻烦的方式临时解决，但现在真没必要去尝试了；总之现在（2025）至少也应该使用 [LTS](https://www.oracle.com/java/technologies/java-se-support-roadmap.html) 版本 11、但推荐更高的 LTS 17 / 21 等。
- 作为大企业 IT，应该可以尝试 Go 语言开发了。

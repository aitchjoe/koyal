---
title: 代码质量和技术债
---

## 背景

以 SonarQube 为契机，先谈谈它的局限。SQ 及其他常见代码质量工具如 Checkstyle、ESLint 主要聚焦于语言层面，如果定位到 Bug 或安全漏洞当然是应该马上解决，但是涉及到重要不紧急的 Code Smell 技术债，所能起到的效果就比较尴尬。

比如一个 Java 应用，如果现在还是 JDK 6，那么即使一个 Code Smell 也没有，它的技术债也远大于有 10000 个 Code Smell 的 Java 8/11 应用。同理也包括使用着过时的 Spring 框架、还在用 Ant 而非 Maven/Gradle、内部的 SPA 应用仍然只基于 JQuery 等等等等。

SQ 还有的一个 New Code 特性，乍看是同类产品缺失的且设计很务实，让开发人员先聚焦新写的代码质量。但和上面的情况一样，如果基于 Java 6 那么新代码永远使用不上 Lambda、同样配置下就是比 Java 8 Runtime 慢......这种情况下的新代码质量提升显然是先天不足。

之前和 SQ 的人沟通希望能提供类似以上的技术栈扫描，但现在个人觉得不是他们做不到，而是做出来后更尴尬。在如 Java 6 这样的技术债大山压迫下，所有的细节优化都显得茫然，回避真正困难的结果就是不会有真正的质量提升！

当然这并不是否认语言层级代码扫描的作用，在根基已经打好的前提下对一线的开发人员帮助很大；但是对于架构、管理层面，SQ 目前提供的技术债指标反而容易产生误导，因此我们希望梳理出一批更能反应实际情况的代码质量指标。

## 指标梳理

### 说明

指标的选择主要考虑以下原则：

- 容易获取：如果评估方案复杂或严重依赖评估人的水平，即使结果再有价值也无法大规模实用。
- 语义清晰：如果一个指标结果有多种甚至相反的解读那么就没有价值了；另外不追求解读太复杂的含义，即使只达到简单目的、能准确就好。

这两者必须综合考虑，比如代码提交次数这个指标很容易获取，但是次数的多少既不能精确的反应工作量、更绝对反应不出代码质量，那么这个指标就没有价值。但是如果我们稍微加工一下这个数据，我们不管某个开发人员一天提交几次、都算他当天有开发行为，然后我们统计他每个月有开发行为的天数，然后把时间拉长到半年或更多，那么这个指标虽然不能反应开发人员的水平、但是基本能确定他到底有没有在做开发。

当然这种做法仍然可能会对个案不公平，但从统计角度可以认为是准确的了，比如虽然不能说 Java 6 应用就一定比 Java 8 差，但是前者确实是更早成为 Legacy，而这也没有否认它的历史贡献。事实上即使强求严谨也做不到，如果质量这种东西能够真实完整的数字化，那么也不存在所谓战略眼光或者管理的困扰了；现实就是一旦数字化，自然就有伪造指标的应对之策了，莫不如此。

### 技术栈

如上所述，这是最主要的代码质量 / 技术债指标：

- 开发语言版本：对于 Java，11 > 8 >>>>> 6（4 负分）；对于 JS，TS = ES6 > ES5。（TODO：补充使用广泛的其他语言技术栈。）
- 主要开发框架版本：Spring Boot 2 > 1 >> Spring Framework 4 >>> 3；Vue = React >> JQuery（注意这个是有适用场景的，此处不展开。）
- 包管理方式：Maven = Gradle；NPM = Yarn；缺失负分。
- 源代码管理： Git >>> SVN（因为不仅是存储，会很大程度影响开发流程和协作方式。）
- 自动化测试：大课题，另起一章。
- 持续集成：Jenkins = GitLab CI，缺失负分。
- 代码扫描：spring-javaformat = ESLint > SonarQube（SQ 规则不能跟源码一起版本化是最大的扣分项，但是其他语言如果没有现成工具 SQ 应该是一个选项。）
- 其他工具和插件：能够用工具插件自动化解决的问题就不靠文档或口口相传，比如环境依赖检查或代码格式化，比如 Maven Wrapper，有就是加分项。
- 部署：容器、Kubernetes 显然是技术主流方向。
- 可观察性：应用是否启用 Prometheus、分布式追踪，是否集中采集到可观察性平台。
- HTTP Vs HTTP/2（gRPC）。

### 自动化测试

以下都是大的加分项。

- 上线主要依赖自动化测试。
- 开发人员负责自己开发功能的自动化测试。
- 出现 Bug 后，在评估不是简单的笔误而是比较复杂逻辑引起时，能够先写测试程序捕获该 Bug 然后再解决。
- 前端有 E2E 测试：Cypress > Selenium。
- 开发环境能够一键就位，主要是外部依赖能够自动部署和重置、或者 Mock。
- 在持续集成中运行自动化测试，而不是 skip test。
- 以下情况越往下、越有信心（有信心的表现是不会以任何理由再三拖延这个工作），加分越多：
  - 批量修改 Code Smell。
  - 语言或开发框架中小版本升级。
  - 语言或开发框架大版本升级。

### 敏捷

小步伐、快节奏必然更优，不争论。

- 生产环境的发布频次。
- 开发分支合并回主干的间隔。
- 技术栈的升级节奏。

### 自主

这个主题看似和技术无关，但实际是决定技术质量的根本！

- 外包占比。并不是说内勤开发质量就没问题，但是外包开发必然质量不高：
  - 甲方乙方的诉求是有差异的。
  - 合同只能约束任务数量，除有限的如并发等，是无法约束项目质量的。也尝试以上面的技术栈指标评估市场产品，结果是太严苛了。
  - 既然不允许外包上网，人家也很难完成提升质量的研究工作。
- 内勤开发人员有代码提交行为的占比（注意仅仅是 Merge 别人代码的这种提交不算）。
- 解决技术问题不需要外包人员出面的占比。
- 内勤主管人员能够主导技术设计的占比。
- 团队是否有专人专责负责非业务功能的技术事项，不论自研或对接公共团队。
- 每年在非业务功能开发上的工时投入和占比。

### 专业度

- 安全：
  - 东西向服务间调用：现在非常多的应用仍然是仅仅依赖网络权限控制，而网络权限只能开或关、无法做到按操作类型或数据范围做细粒度的控制，而这些要求是很难依赖外部 API Gateway 的。
  - 实现：总的来讲业务逻辑之外的功能应该尽量使用第三方主流框架或库，特别是安全领域，自己实现不是优点而是隐患！即使实际上不是从零做起。
  - HTTPS：应该只支持 HTTPS，即使 HTTP 自动跳转 HTTPS 仍有漏洞。
- 规范性：
  - 使用域名和标准端口，而非 IP。
  - HTTPS 使用正式证书而非自签名证书。
- 公共平台利用度。重点仍然是业务逻辑之外的功能尽量不要自己实现，尊重专业产品的专业实现：
  - 如 LDAP 这种最通用的，对于内部应用来说能用不用是扣分项。
    - 但现在 LDAP 有个问题就是测试环境不是正式的用户数据，而实际上测试环境不代表就是临时的，很多在测试环境的应用如 OpenShift 等仍然是生产级别的服务、用户登录应该使用同样的用户密码。
  - SSO。
  - Object Storage。
- REST API：
  - 最起码在调用出错时能通过 HTTP Status Code 反应基本的错误种类，而非泛泛的 200。
- 二级管理、自助服务。
  - 除了用户向的支持外，面向开发者的自助服务也很重要，典型的如服务间调用的 Token 自助申请及更新。
- 功能实现中真正业务逻辑的占比：这个指标估计很难实现，貌似也未在 SonarQube 的 Rules 中找到。主要针对的是不会利用框架、库或平台提供的现成功能，100 行的程序有 90 行是在把 Java Object 拼成 JSON 串或者把 XML 字符串解析成 Java Object、或者编写用户登录校验的功能，只有 10 行是真正处理业务。

### 其他

- 源代码管理内容：除代码外，数据库 Schema、基础数据及示例数据、CI / CD 配置、脚本、开发文档等等都应该同步管理。
- 前端对浏览器的支持：最起码现在应该要支持 Chrome 或 Chrome 内核的其他浏览器，面向外部客户的应用应尽可能的都支持，这也是以上提及的某些场景下不用 Vue 不代表落后的原因。
- 代码删除行数：功能未变的前提下清理代码就表示在提高质量。
- Code review：如果没有互动（评论、打回）只有 Merge 那约等于无。
- Repository size：代表应用复杂度（即使实际业务不复杂、但也能一定程度上说明被做得复杂了），另外如果一组微服务中某一个 Size 远大于其他的，也能说明拆分问题。

当然还有更多常规指标，但是如代码提交频次、行数等等，个人不觉得有多大意义，另外如从需求到投产全流程，可能有很大意义但是较难跟踪，可以进一步讨论。

### 隐含指标

如果指标结果出来了，如果也都承认重要，但是最终却没有改变，那么就说明有权重极大的指标隐藏着在影响事情的进程，比如。

## 指标列表

类似以下指标示例，**注意**不要急于计分或设权重，待收集一定数量的事实统计后再调整分值或权重以匹配真实情况，类似监督学习。

| 分类       | 指标                                 | 类型             | 说明                   | 示例                                 |
| ----       | ----                                 | ----             | ----                   | ----                                 |
| 技术栈     | 开发语言版本                         | 有限列表         | 见以下版本说明         | Java 8 / Java 11                     |
|            | 主要开发框架版本                     | 有限列表         | 见以下版本说明         | Spring Boot 2 / Spring Framework 4   |
|            | 包管理方式                           | 有限列表         |                        | Maven / Gradle / NONE                |
|            | 源代码管理                           | 有限列表         |                        | Git / SVN / NONE                     |
|            | 持续集成                             | 有限列表         |                        | Jenkins / GitLab CI / NONE           |
|            | 代码扫描                             | 有限列表         |                        | SonarQube / spring-javaformat / None |
| 自动化测试 | 上线主要依赖自动化测试               | 是否             |                        |                                      |
|            | 开发人员负责自己开发功能的自动化测试 | 是否             |                        |                                      |
|            | 持续集成中运行自动化测试             | 有无             | 见以下集成测试说明     |                                      |
|            | 前端 E2E 测试                        | 有限列表         |                        | Cypress / Selenium / NONE            |
|            | 是否定期修改 Code Smell 问题         | 是否             |                        |                                      |
|            | 是否定期升级语言或开发框架           | 是否             |                        |                                      |
| 敏捷       | 生产环境发布频次                     | 每年平均发布次数 |                        |                                      |
|            | 开发分支合并回主干的间隔             | 百分比           | 总计天数 / 总分支数    |                                      |
| 自主       | 外包占比                             | 百分比           | 按项目，见开发人员说明 |                                      |
|            | 内勤开发人员真正开发占比             | 百分比           | 按部门，见开发人员说明 |                                      |
|            | 解决技术问题主要依靠外包或厂商       | 是否             |                        |                                      |
|            | 内勤主导技术设计                     | 是否             |                        |                                      |
|            | 团队设专人负责非业务技术共性问题     | 是否             |                        |                                      |
|            | 在非业务功能开发上的工时投入占比     | 百分比           |                        |                                      |
|            | Code Review 交互次数                 | 百分比           | 总次数 / 总 Review 数  |                                      |
| 公共平台   | 容器化                               | 是否             |                        |                                      |
|            | 监控                                 | 有无             |                        |                                      |
|            | 日志                                 | 有无             |                        |                                      |
|            | LDAP                                 | 有无             | 见 LDAP 说明           |                                      |
|            | SSO                                  | 有无             |                        |                                      |
|            | 对象存储                             | 有无             |                        |                                      |

- 版本：
  - 主要关注点在于该版本落后主流版本多远。
  - 一般关注到中版本号即可，但并不是 x.y.z 中的 x.y 就代表中版本，不同软件的版本风格不一，只能个案处理。比如 Java，8 到 9 是大版本升级，但是 9 到 10、11 是中版本，其中又有 LTS 的概念比如 11、17 是推荐长期使用的版本。
  - 如果针对这个指标计分，大致 Java 4、6、8、9、10、11、12、13、14 的分值为 -20、-5、0、4、4、5、5、5、5。这个分值的绝对值不重要、主要是差距间隔的大小。
- 集成测试：关注点在于外部依赖能否方便的部署，因此主要考察是否在持续集成中运行相关的集成测试，该问题不考虑是否运行单元测试。
- 开发人员：只统计真正而非名头上的开发人员占比，见以上指标梳理中对开发行为的定义。
- LDAP：主要针对内部应用，面向客户的外部应用没有也不是扣分项。

## 指标实现

主要分两部分：

- 从源代码、Commit 历史、Runtime 环境等自动提取。总之还是希望有现成的工具实现，如果没有可以考虑自主开源技术栈扫描工具:)
- 访谈。这一部分需要精心设计问题，答案以是否为主，保证访谈者无需犹豫即可作答。

以下主要考虑自行实现自动化提取的部分，技术栈方面以 Java 为例：

- pom.xml 或 build.gradle（以下用 pom.xml 代表两者）：
  - 源码没有 pom.xml、有 Jar 文件混在源码，很可能是没有包管理。
  - pom.xml 中通常会定义 Java 版本，但是不可靠，如果是容器应用那么 Dockerfile 中的 JDK 版本是最真实的。
  - 可以从 pom.xml 中解析出所使用的 Spring 框架及版本。
  - 从 pom.xml 的 Commit 历史可以分析出进化节奏。
- GitLab 数据库或 API：
  - 开发行为：不看重提交次数或行数，主要看有提交行为的天数，注意自己不生产代码、只有 Merge 提交记录的不算。
  - Repository Size。
  - Code review 记录。
- More……
